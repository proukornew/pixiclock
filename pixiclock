#!/usr/bin/python

#
# Copyright (c) 2010 Alexey Michurin <a.michurin@gmail.com>,
#                    Mihail Razuvaev (goglus) <goglus@gmail.com>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#

# SETUP SECTIONS
##################################### ALARM
# You can set up alarm clock here.
# Denote as more alarm times as you need.
#
# version 0.3.1: Use option -a HH:MM

ALARMS = ['09:00', '17:45']

##################################### SKIN

SKIN = {

'border': 3,          # Border width

'bgcolor': '#444444', # Backgtound

'fgcolor': '#cccccc', # Foreground

'scale': 2,           # Scaling factor

'digits': (

'''
.OOOOO.
O.....O
O...O.O
O..O..O
O.O...O
O.....O
.OOOOO.

''','''
.O...O.
.OOOOO.
O..O..O
.OOOOO.
.OO.OO.
.OOOOO.
OO.O.OO

''','''

..OO...
...O...
...O...
...O...
...O...
...O...
.OOOOO.

''','''
OO...OO
OOOOOOO
O..O..O
OOOOOOO
O..O..O
..OOO..
OOOOOOO

''','''

.OOOOO.
O.....O
......O
......O
.OOOOO.
O......
OOOOOOO

''','''
..O.O..
...O...
.OOOOO.
OO.O.OO
OOOOOOO
.OO.OO.
..O.O..

''','''

.OOOOO.
O.....O
......O
...OOO.
......O
O.....O
.OOOOO.

''','''
.OOOOO.
O.OOO.O
.OO.OO.
...O...
O.OOO.O
.OO.OO.
O.OOO.O

''','''

....OOO
...O..O
..O...O
.O....O
OOOOOOO
......O
......O

''','''
.O...O.
..OOO..
O.O.O.O
OOOOOOO
..OOO..
OOOOOOO
O.....O

''','''

OOOOOOO
O......
OOOOOO.
O.....O
......O
O.....O
.OOOOO.

''','''

OOO.OOO
..O.O..
..OOO..
.O.O.O.
..O.O..
..O.O..
...O...

''','''

.OOOOO.
O......
OOOOOO.
O.....O
O.....O
O.....O
.OOOOO.

''','''
...O...
.OO.OO.
O.O.O.O
OOOOOOO
O..O..O
OO.O.OO
.OO.OO.

''','''

OOOOOOO
......O
.....O.
....O..
...O...
...O...
..OOO..

''','''
.O...O.
.OOOOO.
O.OOO.O
.OOOOO.
..OOO..
..O.O..
...O...

''','''

.OOOOO.
O.....O
O.....O
.OOOOO.
O.....O
O.....O
.OOOOO.

''','''
.OOOO..
O.O.O..
OOOOO.O
...OOOO
OOOOO..
.OOOO..
..O.O..

''','''

.OOOOO.
O.....O
O.....O
O.....O
.OOOOOO
......O
.OOOOO.

''','''
OOOOOOO
O.OOO.O
OOO.OOO
.O...O.
.OOOOO.
..O.O..
.OO.OO.

''','''

..
OO
OO
..
OO
OO
..
'''
)}

#####################################
# /SETUP SECTIONS


VERSION = '0.3.1'


from Tkinter import Tk, Label, BitmapImage, Menu, Toplevel, Button, Frame, \
                    LEFT, GROOVE, READABLE
from ConfigParser import ConfigParser
import time
import socket
import re
import getopt
import sys


################ CONSTANTS #########################

ABOUT = (  'PixiClock ' + VERSION + '\n'
           '\n'
           'Released under the terms of BSD license.\n'
           '\n'
           'Copyright (c) 2010\n'
           '   Hacked by Alexey Michurin <a.michurin@gmail.com>\n'
           '   Graphic design by Mihail Razuvaev (goglus) <goglus@gmail.com>\n'
           '\n'
           'PixiClock is tiny desktop clock widget for true geeks.\n'
           '\n'
           'Project homepage:\n'
           '   http://pixiclock.googlecode.com/\n'
           'More about pixi-culture:\n'
           '   http://goglus.com/\n'
           '   http://goglus.com/pixel/urod.htm'
        )

HELP =  (  'Comman line options.\n'
           '\n'
           '-v\n'
           '    print version\n'
           '-h\n'
           '    print help message\n'
           '-p PORT\n'
           '    run pixiclock in network mode on PORT; try\n'
           '    $ telnet localhost PORT\n'
           '-a HH:MM\n'
           '    set up alarm; can be used many times\n'
           '-f file\n'
           '    load skin from configuration file\n'
           '\n'
           'Looking for GUI setup? Configuration files?\n'
           '\n'
           'Look into program source, sections ALARMS and SKIN.\n'
           'Some bare comments helps you.\n'
           '\n'
           'Do not forget to make backup copy before you start\n'
           'editing, and use the force, Luke!'
        )


################ NETWORK FUNCTIONALITY #############
# commands
# BG=#000000
# FG=#000000
# GEOMETRY=-10-10
# DELAY=1000

class net_message(Toplevel):

    def __init__(o, r, port):
        Toplevel.__init__(o, r)
        o.withdraw()
        o.overrideredirect(True)
        o.title('pixiclock message')
        o.label = Label(o,
                        bg='#444444',
                        fg='#cccccc',
                        justify=LEFT,
                        font=('Helvetica', 10, 'bold'))
        o.label.pack()
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setblocking(0)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR,
              sock.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR) | 1)
        sock.bind(('127.0.0.1', port))
        sock.listen(100)
        o.tk.createfilehandler(sock, READABLE, o.accept_connection)
        o.message = ''
        o.prog_handler = None
        o.prog = []
        o.prog_re = re.compile('(BG|FG|GEOMETRY|DELAY|PROLONGATE)'
                               '\s*[=:]\s*'
                               '([-+#a-zA-Z0-9]+);?')

    def accept_connection(o, s, m):
        sock, addr = s.accept()
        o.tk.createfilehandler(sock, READABLE, o.recv_data)

    def recv_data(o, s, m):
        d = s.recv(8000)
        if d == '':
            # close connecton
            o.tk.deletefilehandler(s)
            s.close()
            # extract commands and message from text
            pos = 0
            prog = []
            mess = ''
            pre_defaults = {'GEOMETRY': '-10-10',
                            'BG': '#444444',
                            'FG': '#cccccc'}
            delay_found = False
            while True:
                m = o.prog_re.search(o.message, pos)
                if m is None:
                    mess += o.message[pos:]
                    break
                c = m.group(1)
                p = m.group(2)
                delay_found = delay_found or c == 'DELAY'
                if not delay_found:
                    try:
                        del pre_defaults[c]
                    except KeyError:
                        pass
                prog.append((c, p))
                mess += o.message[pos:m.start()]
                pos = m.end()
            o.message = '' # message processed
            o.prog.extend([('TEXT', mess.strip())] +
                          pre_defaults.items() +
                          prog)
            if not delay_found:
                o.prog.append(('DELAY', 5000))
            # start program
            if o.prog_handler is None:
                # we will show window later, on first DELAY
                o.exec_prog_step()
        else:
            o.message += d

    def exec_prog_step(o):
        try:
            while True:
                if len(o.prog) == 0:
                    o.withdraw()
                    o.prog_handler = None
                    return
                c, p = o.prog[0]
                o.prog = o.prog[1:]
                if c == 'BG':
                    o.label.config(bg=p)
                elif c == 'FG':
                    o.label.config(fg=p)
                elif c == 'GEOMETRY':
                    o.geometry(p)
                elif c == 'DELAY':
                    if o.prog_handler is None:
                        o.deiconify()
                        o.lift()
                    o.prog_handler = o.after(int(p), o.exec_prog_step)
                    break
                elif c == 'TEXT':
                    o.label.config(text=p)
                else:
                    raise Exception('Command %s?', c)
        except Exception, e:
            err = 'ERROR %s=%s: %s' % (c, p, str(e))
            print err
            o.prog = [('TEXT', str(err)),
                      ('GEOMETRY', '-10-100'),
                      ('BG', '#990000'),
                      ('FG', '#ffffff'),
                      ('DELAY', 10000)]
            o.prog_handler = o.after(0, o.exec_prog_step)


################ BASE FUCTIONALITY #################


def pix2xbm(data, factor):
    xbm = []
    w = 0
    h = 0
    for l in data.strip().split():
      for g in range(factor):
        if w == 0:
            w = len(l)*factor
        h += 1
        m = 1
        n = True
        for c in l:
          for g in range(factor):
            if n:
                xbm.append(0)
                n = False
            if c == 'O':
                xbm[-1] |= m
            m *= 2
            if m == 256:
                m = 1
                n = True
    return ('#define x_width %d\n'
            '#define x_height %d\n'
            'static unsigned char x_bits[] = {\n'
            '%s};\n'
           ) % (w, h, ', '.join(map(lambda x: '0x%02x' % x, xbm)))


class dialog(Toplevel):

    def __init__(o, r, u, t):
        Toplevel.__init__(o, r)
        o.title(u)
        k = Frame(o, borderwidth=0)
        k.pack(padx=3, pady=3)
        f = Frame(k, borderwidth=4, relief=GROOVE)
        f.pack(padx=1, pady=1)
        Label(f, text=t, justify=LEFT,
              borderwidth=4).pack()
        Button(k, text='Close', command=o.destroy, pady=0).pack(padx=1, pady=1)


class popup_menu(Menu):

    def __init__(o, r):
        Menu.__init__(o, r, tearoff=0, font=('Helvetica', 8, 'bold'))
        o.root = r
        o.add_command(label='Alarms', command=o.alarms_dialog)
        o.add_command(label='About', command=o.about_dialog)
        o.add_command(label='Help', command=o.help_dialog)
        o.add_command(label='Exit', command=r.quit)

    def about_dialog(o):
        dialog(o.root, 'About', ABOUT)

    def help_dialog(o):
        dialog(o.root, 'Help', HELP)

    def alarms_dialog(o):
        if ALARMS:
            a = '\n'.join(ALARMS)
        else:
            a = '(empty)'
        dialog(o.root,
           'Alarms',
           'List of alarms:\n' + a)


class window(Tk):

    def __init__(o, alarms):
        Tk.__init__(o)
        o.overrideredirect(True)
        o.title('pixiclock')
        o.labels = []
        for n in range(8):
            l = Label(o)
            o.labels.append(l)
            l.grid(column=n, row=0)
        o.popup = popup_menu(o)
        o.load_skin()
        o.digital_mode = False
        o.alarms = alarms + ALARMS
        o.alarm_mode = 0
        o.alarm_x = None
        o.alarm_y = None
        o.alarm_done = ''
        o.bind('<1>', o.start_motion)
        o.bind('<3>', o.popup_menu)
        o.bind('<B1-Motion>', o.continue_motion)
        o.bind('<Enter>', o.mouse_enter)
        o.timer_loop()

    def popup_menu(o, e):
        o.popup.tk_popup(e.x_root, e.y_root, 0)

    def start_motion(o, e):
        o.lift()
        o.start_motion_x = e.x_root - o.winfo_x()
        o.start_motion_y = e.y_root - o.winfo_y()

    def continue_motion(o, e):
        x = e.x_root - o.start_motion_x
        y = e.y_root - o.start_motion_y
        if -10 < x < 10:
            x = 0
        d = o.winfo_screenwidth() - o.winfo_width()
        if -10 < x - d < 10:
            x = d
        if -10 < y < 10:
            y = 0
        d = o.winfo_screenheight() - o.winfo_height()
        if -10 < y - d < 10:
            y = d
        o.geometry('+%d+%d' % (x, y))

    def mouse_enter(o, e):
        if not o.digital_mode:
            o.lift()
            o.digital_mode = True
            o.update_digits()
            o.after(2000, o.undigital_mode)

    def undigital_mode(o):
        o.digital_mode = False
        o.update_digits()

    def load_skin(o):
        # ---
        # May be, in future, i implement menudriven skin engine.
        # I believe.
        skin = SKIN
        # ---
        o.digits = []
        for n in range(21):
            d = pix2xbm(skin['digits'][n], skin['scale'])
            o.digits.append(BitmapImage(data=d,
                                        foreground=skin['fgcolor'],
                                        background=skin['bgcolor']))
        for l in o.labels:
            l.configure(borderwidth=skin['border'],
                        background=skin['bgcolor'])
        for l in o.labels[2:6:3]:
            l.configure(image=o.digits[20])

    def update_digits(o):
        hms = time.localtime()[3:6]
        hm = '%02d:%02d' % tuple(hms[:2])
        if hm in o.alarms and hm != o.alarm_done:
            o.alarm_done = hm
            o.start_alarm()
        d = 1
        if o.digital_mode:
            d = 0
        for n, v in enumerate(hms):
            o.labels[n*3].configure(image=o.digits[(v/10)*2 + d])
            o.labels[n*3+1].configure(image=o.digits[(v%10)*2 + d])

    def timer_loop(o):
        o.update_digits()
        o.after(1000, o.timer_loop)

    def start_alarm(o):
        if o.alarm_mode:
            return
        o.alarm_mode = 1
        o.alarm_x = o.winfo_x()
        o.alarm_y = o.winfo_y()
        o.continue_alarm()

    def continue_alarm(o):
        o.alarm_mode += 1
        if o.alarm_mode > 50:
            o.alarm_mode = 0
            o.geometry('+%d+%d' % (o.alarm_x, o.alarm_y))
        else:
            o.lift()
            dx, dy = 5*(1-2*(o.alarm_mode%2)), 0
            if (o.alarm_mode/10)%2 == 0:
               dx, dy = dy, dx
            o.geometry('+%d+%d' % (
                  (o.winfo_screenwidth() - o.winfo_width())/2 + dx,
                  (o.winfo_screenheight() - o.winfo_height())/2 + dy)
            )
            o.after(100, o.continue_alarm)


def load_skin(file):
    conf = ConfigParser()
    conf.read(file)
    sections = conf.sections()
    if len(sections) == 0:
        raise Exception('There are no sections found in configuration file %s' % file)
    for sect in conf.sections():
        for k, t in (('border', int),
                     ('bgcolor', str),
                     ('fgcolor', str),
                     ('scale', int)):
            SKIN[k] = t(conf.get(sect, k))
        a = []
        for i in range(10):
            a.append(conf.get(sect, 'digit%d' % i))
            a.append(conf.get(sect, 'icon%d' % i))
        a.append(conf.get(sect, 'separator'))
        SKIN['digits'] = a


def main():
    # parse arguments
    try:
        show_version = False
        show_help = False
        net_port = -1
        alarms = []
        opts, args = getopt.getopt(sys.argv[1:], "vhp:a:f:")
        for o, v in opts:
            if o == '-p':
                net_port = int(v)
            elif o == '-v':
                show_version = True
            elif o == '-h':
                show_help = True
            elif o == '-a':
                p = v
                if len(p) == 4:
                    p = '0' + p
                if not re.match(r'^[0-2]\d:[0-5]\d$', p):
                    raise Exception('Incorrect time format %s. Must be HH:MM.' % v)
                alarms.append(p)
            elif o == '-f':
                load_skin(v)
    except getopt.GetoptError, e:
        print str(e)
        return
    except Exception, e:
        print str(e)
        return
    if show_version:
        print ABOUT
        return
    if show_help:
        print HELP
        return
    # start application
    r = window(alarms)
    if net_port > 0:
        net_message(r, net_port)
    r.mainloop()


if __name__ == "__main__":
    main()
